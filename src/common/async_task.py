#
#  Copyright (c) 2019-2023, ETH Zurich. All rights reserved.
#
#  Please, refer to the LICENSE file in the root directory.
#  SPDX-License-Identifier: BSD-3-Clause
#
from hashlib import md5
import time
import logging
import copy


# common status codes
QUEUED   = "100"
PROGRESS = "101"
SUCCESS  = "200"
DELETED  = "300"
EXPIRED  = "301"
INVALID  = "302"
ERROR    = "400"

# upload process states
ST_URL_ASK = "110" # ask for Temp Form URL for upload xternal file to Object Storage
ST_URL_REC = "111" # received Temp Form URL for upload xternal file to Object Storage
ST_UPL_CFM = "112" # on upload process: upload to Object Storage confirmed
ST_DWN_BEG = "113" # on upload process: download from Object Storage to cluster started
ST_DWN_END = "114" # on upload process: download from Object Storage to cluster finished
ST_DWN_ERR = "115" # on upload process: download from Object Storage to cluster error

# download process states:
ST_UPL_BEG = "116" # on download process: start upload from filesystem to Object Storage
ST_UPL_END = "117" # on download process: upload from filesystem to Object Storage is finished
ST_UPL_ERR = "118" # on download process: upload from filesystem to Object Storage is erroneous



status_codes = { QUEUED  : "Queued",
                 SUCCESS : "Finished successfully",
                 PROGRESS: "In progress",
                 DELETED : "Deleted on request",
                 EXPIRED : "Marked for expiration in persistence",
                 INVALID : "Task not longer valid",
                 ERROR   : "Finished with errors",

                 ST_URL_ASK: "Waiting for Form URL from Object Storage to be retrieved",
                 ST_URL_REC: "Form URL from Object Storage received",
                 ST_UPL_CFM: "Object Storage confirms that upload to Object Storage has finished",
                 ST_DWN_BEG: "Download from Object Storage to server has started",
                 ST_DWN_END: "Download from Object Storage to server has finished",
                 ST_DWN_ERR: "Download from Object Storage error",

                 ST_UPL_BEG: "Started upload from filesystem to Object Storage",
                 ST_UPL_END: "Upload from filesystem to Object Storage has finished succesfully",
                 ST_UPL_ERR: "Upload from filesystem to Object Storage has finished with errors"
                }



# task_id: unique task identificator
# status_code: standard status code as stated in status_code
# status_desc: standard status description as stated in status_codes
# data : last output result for the task (generated by client)



class AsyncTask():
    def __init__(self,task_id,user,service=None,system=None,data=None,created_at=None):

        self.task_id = task_id
        self.hash_id = self.get_hashid(task_id,user)
        self.status_code = QUEUED
        self.status_desc = status_codes[QUEUED]
        if data==None:
            self.data = {}
        else:
            self.data = data
        self.user = user
        self.service = service
        self.system  = system
        if created_at==None:
            self.created_at = time.strftime("%Y-%m-%dT%H:%M:%S")
        else:
            self.created_at = created_at
        self.updated_at = self.created_at

    @classmethod
    def deserialise(cls, value):
        
        status  = value["status"]
        user    = value["user"]
        data    = value["data"]
        service = value["service"]
        system = value["system"]
        created_at = value["created_at"]
        task_id  = value["task_id"]

        task = AsyncTask(task_id,user,service=service,system=system,created_at=created_at)
        task.set_status(status,data)

        return task

    # create hash_id as user-task_id MD5 encoded string
    # used for public access to info in Queue
    def get_hashid(self,task_id,user):
        data = f"{user}-{task_id}"
        hash_object = md5(data.encode())
        hex_dig = hash_object.hexdigest()

        return hex_dig

    def is_owner(self,user):
        if self.user == user:
            return True
        return False

    # change defaulta data from {} to None
    def set_status(self,status,data=None):

        self.status_code = status
        self.status_desc = status_codes[str(status)]
        if data != None:
            self.data = data

        self.updated_at = time.strftime("%Y-%m-%dT%H:%M:%S")

    # return status for internal info (returns SSH "certificate" or "action")
    def get_internal_status(self):

        return {
                "task_id": self.hash_id,
                "hash_id": self.hash_id,
                "user": self.user,
                "status": self.status_code,
                "description": self.status_desc,
                "data": self.data,
                "service": self.service,
                "system": self.system,
                "created_at": self.created_at,
                "updated_at": self.updated_at,
                "last_modify": self.updated_at
                }

    # return status for public info, so task_id is discarded
    def get_status(self):

        # hide users certificate and action details
        # ["msg"]["certs"] & ["msg"]["action"]

        # if dict, then a deepcopy is needed, otherwise the dict in "msg" will be shallow copied
        if isinstance(self.data, dict):

            _data = copy.deepcopy(self.data)

            if len(_data) != 0:

                try:
                    if _data["msg"]["cert"] != None:
                        del _data["msg"]["cert"]
                        del _data["msg"]["action"]
                        del _data["msg"]["download_url"]
                except KeyError as e:
                    logging.warning(e.args)
                except Exception as e:
                    logging.warning(e.args)
        else:
            _data = self.data

        return {
                "task_id": self.hash_id,
                "hash_id": self.hash_id,
                "user": self.user,
                "status": self.status_code,
                "description": self.status_desc,
                "data": _data,
                "service": self.service,
                "system": self.system,
                "created_at": self.created_at,
                "updated_at": self.updated_at,
                "last_modify": self.updated_at
                }
